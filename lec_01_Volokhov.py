# Библиотеки Python для научных расчетов и машинного обучения
import sys
import array # библиотека, представляющая массивы данных

import numpy as np
print(np.__version__)

# В Python динамическая типизация -- знание о типе появляется не в момент компиляции программы, а в момент её выполнения
x = 1
print(type(x))

x = "hello"
print(type(x))

# В Python каждая переменная представляет собой объект и поэтому в нём действует сборщик мусора, чтобы можно было удалить переменные, освободить память (ведь Python реализован на С, и каждый из типов представлен в виде C-шной структуры, которая как раз и хранит ссылки для сборщика мусора)

# !Структуры данных!
# Список (поддерживает элементы разных типов)
l = [True, "2", 3.0, 4]
print([type(i) for i in l])

print(sys.getsizeof(l)) # величина всей данной конструкции в байтах

l1 = []
print(type(l1))
print(sys.getsizeof(l1))

# Массив (поддерживает элементы одного типа)
a1 = array.array('i', [])
print(type(a1))

print(sys.getsizeof(a1))

a1 = array.array('i', [1])
print(sys.getsizeof(a1))

a1 = array.array('i', [1,2])
print(sys.getsizeof(a1))
# т.к. значения в массиве однотипные, можно сэкономить память

# почему от нативного массива Python переходим к использованию массива из библиотеки NumPy: т.к. в ndarray хранение данных получается более эффективным, но главное, что NumPy добавляет возможность выполнения многих операций более эффективным методом, и операций, который стандартный array не предоставляет.
# популярные библиотеки представления данных (такие как Pandas) основаны на NumPy

# NumPy & Python array -- массивы хранят элементы одного типа

# Как можно создавать массивы в NumPy?
# создание из списка:
l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a = np.array(l)
print(a)
print(type(a))

print("list(python)", sys.getsizeof(l))
ap = array.array('i', l)
print("array(python)", sys.getsizeof(ap))
print("array(numpy)", sys.getsizeof(a))

# но на больших данных NumPy будет работать лучше

# "повышающее" приведение типов в NumPy (т.е. тип элементов массива выбирается по тому элементу, которое имеет наибольший вес)
a = np.array([1.01, 2, 3, 4, 5]) # от целых в действительные
print(type(a), a)

a = np.array([1.01, 2, 3, 4, 5, "a"]) # от чисел в строки
print(type(a), a)

# явное задание типа
a = np.array([1.99, 2, 3, 4, 5], dtype=int) # округление действительного числа в меньшую сторону, просто отбрасывая его дробную часть
print(type(a), a)

# одномерные массивы: range (i, j) --> i, i+1, ..., j-1
a = np.array(range(2, 5))
print(a)

# многомерные массивы
a = np.array([range(i, i + 5) for i in [1, 2, 3]])
# поэлементный вывод:
# 1 2 3 4 5
# 2 3 4 5 6
# 3 4 5 6 7
print(a)

# создание массивов "с нуля" по определенным шаблонам

# массив из нулей:
print(np.zeros(10, dtype=int))

# массив из единиц:
# одномерный
print(np.ones(10, dtype=int))

# многомерный (3 строки, 5 столбцов)
print(np.ones((3, 5), dtype=float))

# предопределенное значение, из которого будет состоять массив
print(np.full((3, 3), 3.1416))

# линейная последовательность чисел
print(np.arange(0, 20, 2)) # разбиение интервала [0, 20) с шагом 2
print(np.arange(0, 20, 3)) # разбиение интервала [0, 20) с шагом 3

# генерация значений в массиве с одинаковыми промежутками между собой:
print(np.linspace(0, 1, 11)) # число элементов в массиве: 11, границы массива: [0, 1]

# Заполнение массива случайными величинами по определенному распределению
# равномерное распределение от 0 до 1
print(np.random.random((2, 4))) # размер массива: 2 строки, 4 столбца

# нормальное (гауссово) распределение
print(np.random.normal(0, 1, (2, 4))) # 0, 1 -- среднее значение и стандартное отклонение; размер массива: 2 строки, 4 столбца

# равномерное распределение от x до y
print(np.random.randint(0, 5, (2, 2))) # диапазон от 0 до 5, заполняем матрицу 2x2

# единичная матрица
print(np.eye(5, dtype=int))

# С какими числовыми типами данных работает NumPy?
# Типы данных
a1 = np.zeros(10, dtype=int)
a2 = np.zeros(10, dtype='int16')
a3 = np.zeros(10, dtype=np.int16)
print(a1, type(a1), a1.dtype) # python
print(a2, type(a2), a2.dtype) # np
print(a3, type(a3), a3.dtype) # np

# a1 = np.zeros(10, dtype=int16)
# NameError: name 'int16' is not defined

# NumPy = Numerical Python
# - работа с атрибутами массивов (размер, форма, типы данных, количество занимаемой памяти)
# - индексация (как обращаться к отдельным элементам массивов или к его частям)
# - срезы (как получать кусочки массивов и как заменять элементы)
# - изменение формы массива (из массива 4x4 сделать 16x1)
# - объединение и разбиение

# Атрибуты: ndim - число размерностей (у массива-строки размерность 1, у массива строка-столбец размерность 2 и т.д.), shape - размер каждой размерности массива, size - общий размер массива

# чтобы генератор случайных чисел работал одинаково при многократных запусках используют метод seed (т.е. seed распространяется на весь класс случайных чисел)
np.random.seed(1)

x1 = np.random.randint(10, size = 3) # массив из 3-х элементов, значения которого лежат от 0 до 9
print(x1)
print(x1.ndim, x1.shape, x1.size) # shape - это кортеж
# 1 (3,) 3

x2 = np.random.randint(10, size=(3, 2)) # массив: 3 строки, 2 столбца
print(x2)
print(x2.ndim, x2.shape, x2.size)

x3 = np.random.randint(10, size=(3, 2, 2)) # массив: 3 строки, 2 столбца
print(x3)
print(x3.ndim, x3.shape, x3.size)

# Индексация (доступ к элементам массива)

# одномерные массивы
a = np.array([1, 2, 3, 4, 5])
print(a[0])
print(a[-2])

a[1] = 20
print(a)

# многомерные массивы
a = np.array([[1, 2], [3, 4]])
print(a)

print(a[0,0])
print(a[-1,-2]) # последняя строка (т.е. [3, 4]) , второй с конца элемент (т.е. 3)

a[1, 0] = 100
print(a)

# вставки
a = np.array([1, 2, 3, 4, 5])
print(a.dtype)

a[0] = 3.14
print(a)
print(a.dtype)

a.dtype = float
print(a)
print(a.dtype)

# типы на ходу менять не надо

# типы, заданные в начале, никак не способствуют конвертации данных, которые в массив вкладываются
# смена типов в runtime может привести к ошибкам и нехорошим последствиям

# Срезы - подмассив массива, задается: [начало:конец:шаг] - по умолчанию [0:<конец>:1]
# индексы:    0  1  2  3  4
a = np.array([1, 2, 3, 4, 5])

print(a[:3]) # первые три элемента массива

print(a[3:]) # элементы с индексами > 2

print(a[1:4]) # все элементы без крайних

print(a[::2]) # только четные по индексам элементы
print(a[1::2]) # только нечетные по индексам элементы

# шаг < 0 [начало:конец:шаг] --> [конец:начало:шаг]

a = np.array([1, 2, 3, 4, 5])
print(a[::-1]) # вывод элементов в обратном порядке

# Срезы в многомерных массивах
a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
print(a)

print(a[:2, :3]) # две первые строки, а из них три первых столбца
print(a[:, ::2]) # три строки и каждый второй столбец
# 1 3
# 5 7
# 9 11

print(a[::-1, ::-1]) # запись матрицы в обратном порядке

print(a[:, 0]) # первый столбец (при этом в выводе представляется не как столбец, а как одномерный массив)
print(a[0, :]) # первая сттрока (":" -- значит от начала до конца)
print(a[0]) # первая сттрока (в N-мерных массивах)

# Срезы в Python - копии подмассивов, а в NumPy - представление (view) (т.е. ссылки на них)
# Т.о. можем, получив срез, повлиять на основной массив (избежав ненужного копирования)

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
print(a)

a_2x2 = a[:2, :2]
print(a_2x2)

a_2x2[0,0] = 999
print(a)

a_2x2 = a[:2, :2].copy() # с помощью copy ничего не расшаривается между элементами, т.к. view превратился в отдельный массив
print(a_2x2)

a_2x2[0,0] = 1001
print(a_2x2)
print(a)

# Форма массива. Изменение

a = np.arange(1, 13)
print(a, a.shape, a.ndim)

print(a[3])
print(a[11])

a1 = a.reshape(1, 12) # получаем массив в массиве, получили две размерности (т.е. один элемент нулевой размерности, другой элемент второй размерности)
print(a1, a1.shape, a1.ndim)
print(a1[0, 3])
print(a1[0, 11])

a2 = a.reshape(2, 6) # 2 строки, 6 столбцов; 2 размерности
print(a2, a2.shape, a2.ndim)

# 12 = 2*2*3 = 12*1 = 1*12*1*1
a3 = a.reshape(2, 2, 3) # 3 размерности
print(a3, a3.shape, a3.ndim)
print(a3[0, 1, 2])

a4 = a.reshape(1, 12, 1, 1)
print(a4, a4.shape, a4.ndim)
print(a4[0, 2, 0, 0])

a5 = a.reshape((2, 6))
print(a5, a5.shape, a5.ndim)
print(a5[1,4])

a6 = a.reshape((2,6), order="F") # можно заменить порядок заполнения массива (order="C" -- из языка C (по умолчанию), order="F" -- Fortran)
print(a6, a6.shape, a6.ndim)
print(a6[1,4])


a = np.arange(1, 13) # в NumPy [ 1  2  3  4  5  6  7  8  9 10 11 12] (12,) не является матрицей
print(a, a.shape, a.ndim)

a1 = a.reshape(1, 12) # чтобы превратить вектор в матрицу-строку, нужно сделать reshape, как бы добавив ещё одно измерение
print(a1, a1.shape, a1.ndim)

# Но можно вместо reshape сделать через newaxis:
a2 = a[np.newaxis, :]     # переменная a -- имеет размерность 1, с помощью newaxis мы добавляем ещё одну ось (размерность) на нулевой позиции
print(a2, a2.shape, a2.ndim)

a3 = a[:, np.newaxis]     # добавляем ещё одну размерность с другой стороны
print(a3, a3.shape, a3.ndim)