import numpy as np

# будем комбинировать векторизованную индексацию с другими схемами индексации

# простые индексы + векторизованная индексация:

# возьмем массив из 12 элементов от 0 до 11, формы 3 строки 4 столбца:
x = np.arange(12).reshape((3, 4))
print(x)

# print(x[2])

# в качестве второго индекса можно указать векторизованный индекс: список, состоящий из определенных элементов
# берется вторая строка, и в ней элементы выводятся в порядке, указанном во втором индексе [2, 0, 1]
# print(x[2, [2, 0, 1]])

# print(x[[2, 0, 1], 2])

# ответ -- одномерный массив длины три, а не матрица состоящая из одной строки, трех столбцов

# срезы + векторизованная индексация:
# print(x[1:])

# print(x[1:, [2, 0, 1]])

# маскирование + векторизованная индексация:
mask = np.array([1, 1, 1, 0], dtype=bool)
print(mask)
print(mask.shape)

row = np.array([0, 2]) # какие строки нужны для управления через маску

# из row нужно сделать сначало две размерности

print(row[:, np.newaxis].shape)

print(x[row[:, np.newaxis], mask])

# mask = np.array([1, 1, 1, 0], dtype=bool)
# row = np.array([0, 1, 2])

# рассматривали способы расширения массивов (правила транслирования); в случае с двумя массивами
# эта операция транслирования и возникает

# хоть размер у маски 3х4, единиц только три, конечный ноль макси не участвует,
# и получается два кортежа
# print(mask.shape)
# (3,)
# print(row.shape)
# (3,)

# x[0][0] x[1][1] x[2][2]
# print(x[row[:], mask]) # Поэтому в результате получаем одномернный массив размерности (3,)

# если в маску запихнем четыре значимых элемента (т.е. четыре единицы [1, 1, 1, 1]), то не сработает,
# т.к. в mask.shape будет (4,), и мы не сможем привести их к одной размерности
# возникает ошибка: IndexError: shape mismatch: indexing arrays could not be
# broadcast together with shapes (3,) (4,)

# чтобы от этой ошибки избавиться, необходимо в row добавить ещё одно измерение,
# сделать row.shape размерности (3,1), а mask.shape - (4,), тогда будет в результате -> row: (3,1); mask:(1,4)
# -> row: (3,4); mask:(3,4)
# Поэтому добавим в row новую ось, и по правилам транслирования придем к матрице 3х4:
# print(x[row[:, np.newaxis], mask])

# Графически покажем, как это можно использовать
# сгенерируем некоторое количество точек на двумерной плоскости и часть из них выделим, зная их индексы

rng = np.random.default_rng(seed=1)
x = rng.multivariate_normal([0, 0], [[1, 2], [2, 5]], 100) # нормальное двумерное распределение
# возьмём квадратную матрицу и сто элементов

print(x.shape)

import matplotlib.pyplot as plt
#
# # plt.scatter(x[:, 0], x[:, 1])
#
# # из этих величин выберем случайно 30 точек каких-нибудь
# np.random.seed(0)
# inx = np.random.choice(100, 30, replace=False)
# print(inx)
#
# # выделим точки с этими индексами как-то по-другому
# select = x[inx]
#
# plt.scatter(x[:, 0], x[:, 1], alpha=0.3)
# plt.scatter(select[:, 0], select[:, 1], s=200, facecolor="none", edgecolor='black')
#
# plt.show()

# т.е. с помощью такой индексации можно легко выделять и рисовать элементы на картинках

# С помощью векторизованной индексации можем менять часть массивов

x = np.arange(10)
print(x)
# inx = np.array([2, 8, 4, 1])
#
# # x [inx] = 99
# # x [inx] += 1
# print(x)

# если есть повторяющиеся элементы:
inx = np.array([2, 8, 4, 1, 4])
# то делаем так:
np.add.at(x, inx, 1) # метод at - аккумулирование, доп. сложение
print(x)

# Пример использования этого: разбиение данных на интервал
rng = np.random.default_rng(seed=1)
x = rng.integers(100, size=100)
print(x[:10])
# хотим посмотреть, сколько чисел попало в интервал

bins = np.linspace(0, 100, 11) # на интервале от 0 до 100, 11 точек, 10 интервалов
print(bins)

counts = np.zeros(11)
print (counts)

# Для этого есть спец. функция
i = np.searchsorted(bins, x)
print(i[:10])

# теперь считаем, сколько индексов куда попало

np.add.at(counts, i, 1)
print(counts)

print(sum(counts))

# с помощью этого типа индексации можно посчитать кол-во элементов, попавших в тот или иной интервал

# СОРТИРОВКА МАССИВОВ
a = [3, 2, 5, 1, 41, 61, 78, 31, 54, 6, 32, 21, 4, 56]
# сам Python работает с сортировкой
# print(sorted(a))
# print(a) # сам массив не меняется
#
# # если хотим поменять сам массив
# a.sort() # меняет сам массив
# print(a)

# на больших данных всё это работает очень медленно

# Теперь рассмотрим массив NumPy
x = np.array(a)
print(x)

print(np.sort(x)) # аналог sorted в Python
print(x)
#
# x.sort() # меняет сам массив
# print(x)

# ЕСЛИ хотим получить не ОТСОРТИРОВАННЫЙ массив, а индексы отсортированных аргументов

inx = np.argsort(x) # метод возвращает индексы
print(inx)

print(x[inx])

# делали сортировку целого массива

# сортировка отдельных строк и столбцов
rng = np.random.default_rng(seed=1)
x = rng.integers(0, 10, size=(4,6))
print(x)

print(np.sort(x, axis=1)) # axis=1 значит по столбцам схлапывается, т.е. сортировка будет по строкам
print(np.sort(x, axis=0))

# LAST THEME in NumPy
# рассматривали массивы и они содержали в себе однородные значения;
# в NumPy есть:
# структурированные массивы
# массивы записей

# т.е. в элементе массива может храниться не просто число, а что-то другое, например (имена, возраст, вес)

name = ["Ирина", "Виталий", "Олег", "Саша"]
age = [25, 17, 52, 44]
weight = [55.0, 57, 78, 72]

i = 1
print(name[i], age[i], weight[i]) # для доступа к данным по i-ому человеку неудобно так вызывать всё подряд

# Поэтому, для удобства, есть структурированный массив
# объявление и определение структуры массива:
data = np.zeros(4, dtype={"names": ("name_", "age_", "weight_"), "formats":("U10", "i4", "f8")})

print(data.dtype)

data["name_"] = name
data["age_"] = age
data["weight_"] = weight

print(data)

print(data["name_"]) # список
print(data[0]) # кортеж
print(data[-1]["name_"])

# ТЕПЕРЬ про Массив записей
# доступ к элементам записи покороче немного

data_rec = data.view(np.recarray)
print(data_rec)

print(data_rec.name_)
print(data_rec[0])
print(data_rec[-1].name_)

# Здесь работает всё, что связано с маскированием и индексацией
print(data["age_"] < 30)

print(data[data["age_"] < 30])
print(data[data["age_"] < 30]["name_"])

# Можно использовать не только простые, но и СЛОЖНЫЕ типы

tp = np.dtype([("id", "i8"), ("mat", "f8", (3, 3))])
x = np.zeros(2, dtype=tp)
print(x)

x["mat"][0] = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

print(x)

data = [("Ирина", 25, 55), ("Виталий", 17, 57)] # список из двух кортежей

dtype={"names": ("name_", "age_", "weight_"), "formats":("U10", "i4", "f8")}

data_rec = np.rec.array(data, dtype=dtype)
print(data_rec)

print(data_rec.name_)

# основной упор на библиотеку NumPy делается, когда работаем с большими данными из-за более
# компактного хранения данных чем в Python

# Pandas - надстройка над NumPy; более приспособлена для работы с многомерными данными
# В NumPy максимум работали с массивами, их индексами и измерениями
# В Pandas индексы (мерки) могут быть не только числовыми + различные группировки, сводные таблицы