import numpy as np

# Правила транслирования (broadcasting)
# В случае, когда обрабатываемые элементы (массивы), которые мы оперируем между собой, не равны,
# дополнить или расширить размеры по различным осям этих массивов помогает процедура транслирования

# Правила транслирования:
# 1. Сравниваются размерности двух массивов. Если размерности отличаются, то форма массива с меньшей размерностью
# дополняется единицами с левой стороны

# 2. Если формы двух массивов не совпадают в каком-то измерении, то массив с формой, равной 1 в данном измерении,
# "растягивается" до соответствия форме другого массива

# 3. Если в каком-либо измерении размеры массивов различаются, и ни один не равен 1, то генерируется ошибка

# Пример 1: хотим сложить два массива
a = np.ones((2, 3))
b = np.arange(3)
# c = np.ones((1, 3))

print(a)
print(b)
# print(c)

# print(a.shape)
# print(b.shape)
# print(c.shape)

# ВАЖНО! Одномерный массив -- не то же самое, что строка определенной длины

c = a + b
print(c)
# [[1. 2. 3.]
#  [1. 2. 3.]]
print(c.shape)
# (2, 3)

# 1. a = (2,3) -> размерность: 2; b = (3,) -> размерность: 1 ==> a = (2,3); b = (1,3) {уравняли размерности,
# по сути превратив b в строку}

# 2. a = (2,3); b = (1,3) ==> b = (2,3) {т.е. т.к. у b есть единичка, то b расстягивается до 2х измерений,
# чтобы соответствовать a
# 2. БЫЛО: а -> 1 1 1
#               1 1 1
#          b -> 0 1 2
#   СТАЛО: а -> 1 1 1
#               1 1 1
#          b -> 0 1 2
#               0 1 2

# 3. a = (2,3); b = (2,3) ==> b добили до размерности массива a, и все хорошо

# Пример 2:
a = np.arange(3).reshape((3, 1))
b = np.arange(3)
print(a)
print(b)

print(a.shape)
print(b.shape)

 # a:
 # [0]
 # [1]
 # [2]
 # b: [0 1 2]
 # a = (3, 1) -> размерность 2
 # b = (3,) -> размерность 1

 # 1. a = (3, 1); b = (3,) ==> a = (3, 1); b = (1, 3)
 # 2. a = (3, 1); b = (1, 3) ==> a = (3, 3); b = (3, 3)
 # ПОСЛЕ 2:
# a: [0 0 0]
#    [1 1 1]
#    [2 2 2]
# b: [0 1 2]
#    [0 1 2]
#    [0 1 2]

print(a + b)
print(a * b) # Умножение поэлементное

# Пример 3:
a = np.ones((3, 2))
b = np.arange(3)

print(a)
print(b)

print(a.shape)
print(b.shape)

# a = (3, 2)
# b = (3,)
# 1. a = (3, 2); b = (3,) ==> a = (3, 2); b = (1, 3)
# 2. a = (3, 2); b = (1, 3) ==> a = (3, 2); b = (3, 3)
# 3.     c = a + b
#         ~~^~~
# ValueError: operands could not be broadcast together with shapes (3,2) (3,)

# БЫЛО:
#  [1 1]
#  [1 1]
#  [1 1]
#
#  [0 1 2]
# СТАЛО:
#  [1 1]
#  [1 1]
#  [1 1]
#
#  [0 1 2]
#  [0 1 2]
#  [0 1 2]

# c = a + b

# Варианты применения транслирования:

# 1) Центрирование массивов

a = np.array([[1,2,3,4,5,6,7,8,9],[9,8,7,6,5,4,3,2,1]])
print(a)

aMean = a.mean(0) # в скобках можно указать размерность (в данном случае это 0 или 1, и тогда среднее
# будет считаться по этой размерности
print(aMean)

print(a.shape)
print(aMean.shape) # - это не вектор-строка, это просто одномерный массив, чтобы сделать его вектор-строкой
# нужно добавить ещё одну размерность

aCentr = a - aMean
print(aCentr) # Центральный элемент = 0, остальные элементы по бокам
print(aCentr.mean(0))

# это было для размерности 0 - столбцы

# Теперь смотрим среднее по строчкам - 1
a = np.array([[1,2,3,4,5,6,7,8,9],[9,8,7,6,5,4,3,2,1]])
print(a)

aMean = a.mean(1)
print(aMean)

print(a.shape)
print(aMean.shape)
# aCentr = a - aMean
#              ~~^~~~~~~
# ValueError: operands could not be broadcast together with shapes (2,9) (2,)

aMean = aMean[:, np.newaxis] # Добавляем новую ось справа, чтобы второе правило транслирования сработало так,
# как нам нужно, и решилась проблема с ValueError: operands could not be broadcast together with shapes (2,9) (2,) ,
# которая возникает потому, что первое правило транслирования делает (2,9) (2,) -> (2,9) (1, 2); а нам
# надо (2,9) (2,) -> (2,9) (2, 1) чтобы все работало и ошибки не возникало
print(aMean)
print(aMean.shape)
aCentr = a - aMean # Теперь работает, ValueError не возникает
print(aCentr)
print(aCentr.mean(1))

# 2) Построение графиков

# import matplotlib.pyplot as plt

x = np.linspace(0, 10, 100) # промежуток от 0 до 10 разбиваем с равным шагом на 100 элементов
y = np.linspace(0, 10, 100)

print(x.shape)
print(y.shape)

z = np.sin(x)*y # этим мы просто перемножили два одномерных массива (кортежа) размерностью x = (100,) и y = (100,)
# получив кортеж z также размерностью (100,)
# print(z)

# А мы хотим сделать матрицу z = 100х100 элементов
# для этого сделаем следующее:
y = y[:, np.newaxis] # благодаря этому запускаем правильную операцию транслирования, которая сработает
print(y.shape)

# Теперь y размерности (100, 1), следовательно x был (100,), а по правилам транслирования станет x = (1, 100)
# тогда z уже будет размером (100, 100)

# z = np.sin(x)*y + np.cos(10 + y * x) ** 3
# print(z.shape)
#
# plt.imshow(z)
# plt.colorbar()
# plt.show()

# НОВАЯ ТЕМА: Маскирование

x = np.arange(1, 6)
print(x)
print(x > 3)
print(x < 3) # универсальная функция
print(np.less(x,3)) # в NumPy записывается вот так
# может быть: >, <, >=, <=, !=, ==  --- каждому из этих элементов соответствует своя УФ

rng1 = np.random.default_rng(seed=1) # seed для отдельного экземпляра, а не для всего класса случ. чисел
rng2 = np.random.default_rng(seed=10)

x = rng1.integers(10, size=(3, 4))
print(x)
# print(x < 6)

# С булевыми массивами есть интересные примеры
# ПРИМЕР: сколько элементов имеют значения меньше 6: для этого можно посчитать, сколько значений True
# True считается 1, False -- 0

# print(np.count_nonzero(x < 6))
# print(np.sum(x < 6))
#
# print(np.sum(x < 6, axis=0)) # можно суммировать по осям: 0 ось - это строчки, НО! мы по ним именно считаем, поэтому
# # число элементов будет как число столбцов
# print(np.sum(x < 6, axis=1))
#
# print(np.any(x > 8)) # Есть ли какой-нибудь любой элемент, больше 8: метод any
# print(np.any(x < 0))
#
# print(np.all(x < 10)) # Проверяем, что все элементы меньше 10
# print(np.all(x != 5))

# Соединяем несколько условий булевскими операторами
# Это всё побитовые булевые операции
# print(np.sum((x > 3) & (x < 9), axis=0)) # И
# print(np.sum((x > 3) | (x < 9), axis=0)) # ИЛИ
# print(np.sum((x > 3) ^ (x < 9), axis=0)) # ИСКЛЮЧАЮЩЕЕ ИЛИ
# print(~np.sum((x > 3) & (x < 9), axis=0)) # ИНВЕРСИЯ
#
# print(np.sum(np.bitwise_and(np.greater(x,3), np.less(x, 9)), axis=0)) # & через операторы NumPy
# Это всё для битовых массивов

# С одной стороны по данным получили маску, а есть обратная операция: зная маску вынуть элементы т.е.:
# НАЛОЖЕНИЕ МАСКИ (маска - булевый массив)

print(x < 5)
# На этот массив x хотим наложить маску, т.е. вынуть только те элементы из него, которые < 5
a = x[x < 5]
print(a)
print(a.shape) # получили одномерный массив a, хоть массив x и является двумерным

# рассмотрим and or & |, которые переводят объект в булевое значение целиком, а не для каждого элемента,
# как мы рассматривали ранее

print(bool(42), bool(0))
print(bool(42 and 0))
print(bool(42 or 0))
# здесь объекты рассматриваются как единое целое
# подробнее об этом
print(bin(42)) # двоичное представление 42
print(bin(11))

print(bin(42 & 11)) # 42 здесь рассматривается как последовательность бит, которая побитово будет И с 59
print(bin(42 | 11))
# print('---')
# print(bool(42 and 59)) # здесь 42 и 59 рассматриваются как отдельные объекты
# print(bool(42 or 59))

# Вместо True и False можно использовать 1 и 0

a = np.array([1,0,1,0,1,0], dtype=bool)
b = np.array([1,1,1,1,1,0], dtype=bool)
print(a & b)
# print(a and b) # на массивах такой оператор И не определен, только на простых элементах

# НОВАЯ ТЕМА: Способы доступа к элементам массива

a = np.arange(10)
print(a)
print(a[3])
print(a[3:4])
print(a[a == 3])

# Векторизованная / прихотливая (fancy) индексация
a = np.arange(1, 10)
print(a)
ind = [3,5,0]
print(a[ind])

ind = [[3,5],[0,3]] # когда индексация идет в такой прихотливой форме, результат отражает
# структуру индекса, но не исходного массива (из массива берутся только данные, а расположение зависит только от нас)
print(a[ind])

a = np.arange(12).reshape((3,4))
print(a)

row = np.array([0,1,2])
col = np.array([2,1,3])
print(a[row, col])

print(row.shape) # (3,)
print(col.shape) # (3,)

# Хотим сделать 3x3 ==> добавим ещё одну ось
print(a[row[:, np.newaxis], col])