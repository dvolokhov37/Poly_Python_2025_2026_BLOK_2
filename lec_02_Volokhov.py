import numpy as np
import timeit

# продолжаем знакомство с библиотекой NumPy

# Слияние и разбиение массивов

# Одномерные массивы (склеиваются вдоль своего размера)
x = np.array([1, 2, 3])
y = np.array([4, 5])
z = np.array([6])

xyz = np.concatenate([x, y, z])
print(xyz)

# Двумерные массивы (размер: 2x3)
x = np.array([[1, 2, 3], [4, 5, 6]])
y = np.array([[7, 8, 9], [10, 11, 12]])
xy1 = np.concatenate([x,y])
print(xy1)

xy2 = np.concatenate([x,y], axis=0) # вдоль оси axis происходит прибавление (склеивание) массивов (по умолчанию axis=0)
print(xy2)

xy3 = np.concatenate([x,y], axis=1)
print(xy3)

# Двумерные массивы склеиваются по одному из двух направлений: axis=0 или axis=1

# В случае различного (множественного) числа измерений

# Есть несколько типов склеивания (для n-мерных массивов (от 3х мерных и более)):
# -вертикальное: vstack
# -горизонтальное: hstack
# -в-глубину: dstack

x = np.array([[1, 2, 3], [4, 5, 6]])
y = np.array([[7, 8, 9], [10, 11, 12]])
print(np.vstack([x, y]))

print(np.hstack([x, y]))

print(np.dstack([x, y]))

# строки - это нулевое измерение (идет вниз)
# столбцы - это первое измерение (идет вбок)
# второе измерение идет как бы в-глубину


# Разбиение массивов

# Массивы можно разбивать по-горизонтали, по-вертикали
# Есть массив как набор элементов; когда разбиваем массив - задаем точки разбиения
# Для N точек разбиения массива, получаем N+1 частей разбиения массива

xy = np.vstack([x, y])
print(xy)

print(np.split(xy, [1])) # в [] скобках задаются точки разбиения; разбиваем по умолчанию по нулевой размерности, т.е. по строкам (axis=0)

# Получается два массива (точка одна (n=1), массивов n+1 - т.е. два)

# Можно при разбиении добавить параметр axis для ориентации разбиения
print(np.split(xy, [1], axis=1))

# По тому же принципу, как и для склеивания, работают vsplit, hsplit, dsplit

print(np.vsplit(xy, [2]))

print(np.hsplit(xy, [2]))

z = np.dstack([x, y])
print(z)

print(np.dsplit(z,[1]))

# Универсальные функции NumPy (используются для ускорения векторизованных операций: ускорение вычислений при работе с векторами)

# Когда хотим сделать однотипную операцию с элементами массива: самый простой способ - это цикл (но это тяжело и дорого с точки зрения ресурсов и памяти)
# Поэтому используются векторизованные операции, которые можно распараллелить, т.к. они выполняются одновременно над каждым элементом массива
# Эти векторизованные операции реализованы через универсальные функции, и они всегда работают гораздо быстрее

x = np.arange(1, 10)
print(x)

# для каждого элемента в массиве хотим найти обратный; можем написать функцию:

def f(x):
    out = np.empty(len(x))
    for i in range(len(x)):
        out[i] = 1.0 / x[i]
    return out

print(f(x))

# как это записать через универсальную функцию: через поэлементное деление 1.0 / x
print(1.0 / x)

# print(timeit.timeit(stmt="f(x)", globals=globals()))
# print(timeit.timeit(stmt="1.0 / x", globals=globals())) # универсальная функция считает в ~10 раз быстрее

# Какие существуют универсальные функции?
# Есть стандартные функции: унарные (один аргумент {пример: знак минус перед числом}) и бинарные (два аргумента {пример: сложение})

# Универсальные функции (УФ). Арифметические операции

x = np.arange(5)
print(x)

print(x + 1)
print(x - 1)
print(x * 2)
print(x / 2)
print(x // 2) # целая часть от деления

print(-x) # унарная операция

print(x ** 2) # возведение в степень
print(x % 2) # остаток от деления по модулю

print(x * 2 - 2) # комбинация операций

# У NumPy есть эквивалетные функции для каждой арифметической операции, записанные через методы класса
print(np.add(x, 1)) # соответствует print(x + 1)
print(x + 1)

x = np.arange(-5, 5)
print(x)

print(abs(x)) # стандартное взятие abs значения в Python
print(np.abs(x)) # взятие abs значения в NumPy
print(np.absolute(x)) # взятие abs значения в NumPy

# NumPy может работать с комплексными числами, и от них абсолютное значение это корень суммы квадратов дейсвтительной и мнимой части
x = np.array([3 + 4j, 4 - 3j])
print(abs(x))
print(np.abs(x))

# В качестве УФ могут использоваться также и тригонометрические функции (прямые и обратные)
# sin, cos, tan, arcsin, arccos, arctan

# В качестве УФ могут использоваться также показательные функции и логарифмы
# exp, power, log, log2, log10

x = [0, 0.0001, 0.001, 0.01, 0.1]
print("exp = ", np.exp(x))

print("exp - 1 = ", np.expm1(x)) # здесь происходит округление, и в случае, если нужна точность, используют exp-1, и так же с log

print("log(x) = ", np.log(x))

print("log(1+x) = ", np.log1p(x)) # и точность повышается, если очень маленькие значения на входе

# УФ. Поразрядная арифметика (радианы в градусы); интегралы гауссовских функций как функции ошибок
# УФ. scipy.special - их лучше использовать вместо циклов

# Тонкие моменты с УФ

x = np.arange(5)
print(x)
y = x * 10
print(y)
y = np.multiply(x, 10)
print(y)

z = np.empty(len(x))
np.multiply(x, 10, out=z) # out - переменная, в которую поместим результат
print(z)

# Почему это может быть полезно

x = np.arange(5)
z = np.zeros(10)
print(x)
print(z)
# Можем сделать присвоение кусочков z
z[::2] = x*10        # здесь будет создан временный массив, а затем он будет скопирован в подмассив z
# 0 0 10 0 20 0 30 0 40 0
print(z)

# Но это будет работать быстрее, если запишем так:
z = np.zeros(10)
np.multiply(x, 10, out=z[::2])
print(z)

# Функции свертки (позволяют получать Сводные показатели)
x = np.arange(1, 5)
print(x)
print(np.add.reduce(x)) # функция reduce означает, что мы многократно применяем к элементам массива одну и ту же операцию
print(np.add.accumulate(x)) # если нам нужно, чтобы промежуточные результаты сложения сохранялись - используем функцию accumulate

# эти функции можно применять не только к сложению, но ещё и к умножению, и к вычитанию, и т.д
print(np.multiply.reduce(x))
print(np.multiply.accumulate(x))

print(np.subtract.reduce(x))
print(np.subtract.accumulate(x))

# Специальные упрощенные функции, эквивалентные данным рассмотренным функциям выше
print(np.sum(x))
print(np.cumsum(x))

print(np.prod(x))
print(np.cumprod(x))

# Таблица сложения или умножения: комбинация всевозможных пар (в данном случае посредством операций сложения или перемножения)
x = np.arange(1, 10)
print(np.add.outer(x, x))

print(np.multiply.outer(x, x))


# Следующая тема: Агрегирование

# np.random.seed(1)
# np.random.randint()
# устанавливали некое начальное значение, чтобы в дальнейшем все функции, котоорые занимаются генерированием
# использовали это значение, и мы получали одни и те же результаты

# недостаток здесь в том, что это случайное значение seed(1) устанавливается для всего класса, поэтому влияло на все датчики случайных величин

np.random.seed(1)
s = np.random.random(100)
print(sum(s)) # python
print(np.sum(s)) # numpy (рабортает быстрее на действительных и больших числах)

# но sum NumPy в отличие от sum Python может работать на многомерных массивах

a = np.array([[1,2,3,4,5],[6,7,8,9,10]])
print(sum(a)) # python
# [ 7  9 11 13 15] - просто суммирует элементы для каждого столбца

print(np.sum(a)) # numpy
# 55 - просуммировала все элементы

# А если хотим, чтобы в NumPy так же, как в Python, суммировалось по столбцам? Тогда задаем параметр axis
print(np.sum(a, axis=0)) # numpy, суммирование по столбцам при axis=0
print(np.sum(a, axis=1)) # numpy, суммирование по строкам при axis=1

# А в Python sum нет второго аргумента axis

print(type(a)) # <class 'numpy.ndarray'> - т.е. массив NumPy, а не простой питоновский
print(a.sum()) # сумма всех элементов массива
print(a.sum(0)) # сумма всех элементов по столбцам
print(a.sum(1)) # сумма всех элементов по строкам

# при суммирование задание измерения - это не то измерение, которое будет возвращено в результате сумирования, а то, по которому будет свернуто
# т.е. если 1 - свернуты будут столбцы, если 0 - строки

# Т.о. можно использовать как метод класса, так и функцию соответствующего экземпляра класса

print(sum(a, 1)) # В Python sum второй аргумент это не ось, а просто начальное значение для суммы

# Минимум / максимум
np.random.seed(1)
s = np.random.random(100)

print(min(s))
print(np.min(s))

print(max(s))
print(np.max(s))

# Для больших объемов (больших значений) NumPy быстрее + NumPy работает с многомерными массивами, всё аналогично

# Ещё некоторые функции агрегирования:
# mean - среднее значение
# std - стандартное отклонение
# var - дисперсия
# median - медиана
# Иногда нужно найти не минимальное значение, например, а индекс, по которому находится минимальное значение:
# тогда используем argmin, argmax
# percentile - квантиль
# any - проверяет, сущесвтует ли какой-либо элемент со значением True
# all - проверяет, все ли элементы со значением True

# Среди элементов массива могут встречаться элементы, которые не являются числами
# Not a number - NaN

# В дальнейшем все эти агрегированные функции имеют свою версию через nan* - тогда эти nan значения либо игнорируются, либо приравниваются нулю

# Универсальные функии позволяют работать с массивами, которые имеют разную форму
# Но прежде, чем такие массивы использовать, они подвергаются операции транслирования (broadcasting)

# Транслирование (broadcasting) - некий набор правил, который позволяет осуществлять бинарные операции с массивами разных форм

a = np.array([1, 2, 3])
b = np.array([5, 5, 5])

print(a + b)
# [6 7 8]

print(a + 5) # здесь 5 - это одномерный массив [5], который не сопоставить так просто с [1, 2, 3]; [5] трансформируется некоторым способом в [5, 5, 5]
# который позволяет уже [1, 2, 3] и [5, 5, 5] складывать между собой
# имеем [1 1 1      [0 1 2]  - здесь [0 1 2] растягивается вниз и будет [0 1 2
#        1 1 1   +                                                       0 1 2
#        1 1 1]                                                          0 1 2]
# также и со столбцами [1                              [1 1 1
#                       2   --> растягиваются вправо    2 2 2
#                       3]                              3 3 3]

# Есть набор правил транслирования:
# 1) Если размерности массива отличаются: у [1, 2, 3] размерность [1, 3] - одна строка, три столбца (размерность: 2);
# а [5] рассматривается как одномерный массив [1,] (размерность: 1)
# то в массив с меньшей размерностью добавляется единичка с левой стороны (столько единичек, сколько нужно)
# т.е. [1, 3] -> [1, 3]; [1,] -> [1, 1]
# Итог: 1) уравнивает число размеров
# 2) Если в каком-то измерении значение размерностей не совпадают и если в каком-то массиве измерение равно единичке,
# то оно растягивается до измерения другого массива
# Итог: 2) для тех размеров, которые не равны, единицу превращаем в элемент соответствующей размерности другого массива (расширение)
# 3) Если начинаем сравнивать значения по всем размерностям, и они не равны друг другу, и при этом ни один из них не равен 1,
# то говорим, что это ошибка, и такие два массива нельзя склеить
